all.True(mtca, ag)
all.equal(mtca, ag)
all.equal(mtca, ag)
all.equal(mtca[1,], ag[1,])
all.equal(mtca[2,], ag[2,])
all.equal(mtca[3,], ag[3,])
all.equal(mtca[4,], ag[4,])
which(mtca, ag)
which(mtca!=ag)
which(mtca!=ag,arr.ind = T)
names(mtca) = NULL
names(ag) = NULL
identical(mtca,ag)
all.equal(mtca, ag)
names(mtca)
colnames(mtca)
rownames(mtca)
rownames(mtca) = NULL
rownames(ag) = NULL
all.equal(mtca, ag)
identical(mtca,ag)
cond = c(Kristina = "Brecko",
Hana = "Choi",
Ron = "Goettler",
Avery = "Haviv",
Yufeng = "Huang",
Mitch = "Lovett",
Takeaki = "Sunada",
Paul = "Which Paul do you want")
last = switch ("Mitch",
cond
)
last
cond
cond = c(Kristina = "Brecko",Hana = "Choi",Ron = "Goettler",
Avery = "Haviv",
Yufeng = "Huang",
Mitch = "Lovett",
Takeaki = "Sunada",
Paul = "Which Paul do you want")
cond
names(cond)
last = switch ("Mitch",cond)
last
last = switch (Mitch,cond)
last = switch ("Mitch",cond)
last = switch ("Mitch",Kristina = "Brecko",
Hana = "Choi",
Ron = "Goettler",
Avery = "Haviv",
Yufeng = "Huang",
Mitch = "Lovett",
Takeaki = "Sunada",
Paul = "Which Paul do you want")
last
cond = list(Kristina = "Brecko",Hana = "Choi",Ron = "Goettler",
Avery = "Haviv",
Yufeng = "Huang",
Mitch = "Lovett",
Takeaki = "Sunada",
Paul = "Which Paul do you want")
cond
last = switch ("Mitch",cond)
last
paste("a",1:10,"_")
paste("a",c(1:10),"_")
paste("a",1,"_")
paste("a",1,sep = "_")
paste("a",c(1:10),sep = "_")
substring("abcdef", first = 1:6, last = 5:6)
string1 <- "+-3-2+1"
gsub("\\D+", "", string1)
gsub("\\D", "", string1)
sub("\\D+", "", string1)
sub("\\D", "", string1)
sentense <- "My phone number is (585)-234-5678.
His phone number is (426)-811-1234.
And the office hotline is (888)-888-8888"
# what are the phone numbers?
split.sentense <- unlist(strsplit(sentense, " "))
phone.numbers <- grep("\\([0-9]{3}\\)\\-[0-9]{3}\\-[0-9]{4}",
split.sentense, value = TRUE)
phone.numbers
missing(d)
optimization_result <- optim(
par = 100, # initial trial value
fn = function(qty) {
- 2*qty
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = 100, # initial trial value
fn = function(qty) {
2*qty^2-2*qty
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = 100, # initial trial value
fn = function(qty) {
-(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = 100, # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = 1000, # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = 1000, # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = 10# initial trial value
fn = function(qty) {
optimization_result <- optim(
par = 40, # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = 400, # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
optimization_result <- optim(
par = c(-1,0.5), # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result <- optim(
par = c(-1,0.5,1,54), # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result <- optim(
par = 0, # initial trial value
fn = function(qty) {
(2*qty^2-2*qty)
} # function with ONE ARGUMENT to MINIMIZE
)
optimization_result[1:2]
sample(x = 1:5, size = 10, replace = FALSE)
sample(x = 1:5, size = 10, replace = FALSE)
sample(x = 1:25, size = 10, replace = FALSE)
sample(x = 1:5, size = 10)
sample(x = 1:5, size = 10, replace = T)
kk = array(1:18,c(3,3,2))
apply(kk, c(1,2), which.max)
apply(kk, c(1,2), length+1)
apply(kk, c(1,2), length)
apply(kk, c(1,2), sum)
b = list()
lapply(b, function(i = 1:5) return(c(1:i)))
lapply(b, function(i = 1:5) b[i] = c(1:i))
lapply(b, function(i = 1:5) return(c(1:i)))
le = 6
lapply(1:le, function(i) return(c(1:i)))
ifelse(c(1, -1, 1) > 0, c(3, 4), c(10, 20, 30, 40))
ifelse(c(1, -1, 1) > 0, c(3, 4), c(10, 30, 40))
ifelse(c(1, -1, 1) > 0, c(3, 4, 6), c(10, 30, 40))
if(c(1,-1,1)>0){}
if (c(1,-1,1) > 0){
c(3,5,6)
} else{
c(10,20,30)
}
X <- array(9:2, dim = c(4, 2))
X[c(2,3)] + X[2,3]
X[c(2,3)] + X[3,2]
X[3,2]
X
df
testdf = data.frame(id = c(1,2), dd = c(3,4), kk = c(5,6))
testdf
testdf[[2]]
as.matrix(testdf)
as.matrix(testdf)[[2]]
as.matrix(testdf)[[2]][1]
testdf[3][1]
testdf[3]
testdf[3][1]
testdf[[3]][1]
as.matrix(testdf[[3]][1])
as.matrix(testdf)[[3]][1]
as.matrix(testdf)[[]][1]
as.matrix(testdf)[[2]][1]
as.matrix(testdf)[[1]][1]
dr = data.frame(mh = c(3,45,6))
df = rbind(testdf, dr)
df
dr
dr[[3]] = NULL
df
dr
dr[3,] = NULL
dr[3,1] = NULL
dr[3,]
dr[3,] = NULL
dr[3,] = NA
dr
dr =dr[-3,]
dr
dr = data.frame(mh = c(3,45,6))
dr[-3,1]
cbind(testdf,dr[-3,1])
testdf = data.frame(id = c(1,2,7), dd = c(3,4,8), kk = c(5,6,9))
testdf
dr[3,1] = NA
na.omit(dr)
testdf[3,1] = NA
na.omit(testdf)
testdf
mean(testdf[[1]])
mean("nn","f")
mean("nn","f",NA)
as.numeric("nn","fg")
mean(as.numeric("nn"))
"ABC" > "bcd"
########### Assignment 1#############
##Q1
prob_no_conflict = pnorm(5,4.5,0.37)
prob_no_conflict
prob_cut_in
prob_cut_in = 1 - prob_no_conflict
prob_cut_in
prob_show = pnorm(4.5,4.5,0.37)
prob_show
prob_long_show = pnorm(4,4.5,0.37)
prob_long_show
cutoff_time = qnorm(0.99, 4.5, 0.37)
cutoff_time
as.Date(cutoff_time)
as.Date(cutoff_time, %h)
as.Date(cutoff_time, %H)
as.Date(cutoff_time, "%H")
as.Date(5, "%H")
as.Date(5, format = "%H")
as.Date(5, format = "%h")
as.Date(5, format = "%p")
make_datetime(hour = 5)
install.packages("lubridate")
library("lubridate")
make_datetime(hour = 5)
k = make_datetime(hour = 5)
minute(k) = 1
k
library("lubridate")
cutoff_time = qnorm(0.99, 4.5, 0.37)
min_time = (cutoff_time - round(cutoff_time))*60
date_cut = make_datetime(hour = round(cutoff_time), min = min_time)
finaltime = as.character(date_cut, format='%H:%M:%S')
finaltiem
finaltime
library("lubridate")
cutoff_time = qnorm(0.99, 16.5, 0.37)
min_time = (cutoff_time - round(cutoff_time))*60
date_cut = make_datetime(hour = round(cutoff_time), min = min_time)
finaltime = as.character(date_cut, format='%H:%M:%S')
finaltime
cutoff_time_tail1 = qnorm(0.025, 16.5, 0.37)
cutoff_time_tail2 = qnorm(0.975, 16.5, 0.37)
min_time_1 = (cutoff_time_tail1 - round(cutoff_time_tail1))*60
min_time_2 = (cutoff_time_tail2 - round(cutoff_time_tail2))*60
date_cut_1 = make_datetime(hour = round(cutoff_time_1), min = min_time_1)
cutoff_time_tail1 = qnorm(0.025, 16.5, 0.37)
cutoff_time_tail2 = qnorm(0.975, 16.5, 0.37)
min_time_1 = (cutoff_time_tail1 - round(cutoff_time_tail1))*60
min_time_2 = (cutoff_time_tail2 - round(cutoff_time_tail2))*60
date_cut_1 = make_datetime(hour = round(cutoff_time_tail1), min = min_time_1)
date_cut_2 = make_datetime(hour = round(cutoff_time_tail2), min = min_time_2)
finaltime_1 = as.character(date_cut_1, format='%H:%M:%S')
finaltime_2 = as.character(date_cut_2, format='%H:%M:%S')
finaltime_1
finaltime_2
df = data.frame(c(0.58,0.12,NULL), c(0.27,0.03,NULL), c(NULL,NULL,1.00))
df
df = data.frame(a = c(0.58,0.12,NULL), b = c(0.27,0.03,NULL), k = c(NULL,NULL,1.00))
df
df = data.frame("Y=0" = c(0.58,0.27,NaN), "Y = 1" = c(0.12,0.03,NaN), "Total" = c(NaN, NaN, 1.00))
df
df = data.frame("Y \= 0" = c(0.58,0.27,NaN), "Y \= 1" = c(0.12,0.03,NaN), "Total" = c(NaN, NaN, 1.00))
df = data.frame("Y \\= 0" = c(0.58,0.27,NaN), "Y \\= 1" = c(0.12,0.03,NaN), "Total" = c(NaN, NaN, 1.00))
rownames(df) = c("X \\= 0", "X \\= 1", "Total")
df
df = data.frame(c(0.58,0.27,NaN),c(0.12,0.03,NaN), "Total" = c(NaN, NaN, 1.00))
rownames(df) = c("X = 0", "X = 1", "Total")
df
df = data.frame(c(0.58,0.27,NaN),c(0.12,0.03,NaN), c(NaN, NaN, 1.00))
rownames(df) = c("X = 0", "X = 1", "Total")
colnames(df) = c("Y = 0", "Y = 1", "Total")
df
df$Total[1:2,]
df$Tota
df$Total
df[,Total]
df[,"Total"]
df[1:2,"Total"]
df$`Y = 0`
df[1:2,"Total"] = df$`Y = 0` + df$`Y = 1`
df[1:2,"Total"] = df$`Y = 0`[1:2,] + df$`Y = 1`{1:2,}
df[1:2,"Total"] = df$`Y = 0`[1:2,] + df$`Y = 1`[1:2,]
df[1:2,"Total"] = df$`Y = 0`[1:2] + df$`Y = 1`[1:2]
df
df = data.frame(c(0.58,0.27,NaN),c(0.12,0.03,NaN), c(NaN, NaN, 1.00))
rownames(df) = c("X = 0", "X = 1", "Total")
colnames(df) = c("Y = 0", "Y = 1", "Total")
df[1:2,"Total"] = df$`Y = 0`[1:2] + df$`Y = 1`[1:2]
df["Total",] = df["X = 0",] + df["X = 1",]
df
df['X = 1',]
sum(df['X = 1',1:2]*1)
df['Total',0]*0 + df['Total',1]*1
df['Total',0]
df['Total',]
df['Total',1]*0 + df['Total',2]*1
df$Total*weight_x
weight_x = c(0,1,0)
df$Total*weight_x
df['X = 0',1]*0/df['X = 0',3] + df['X = 0',2]*1/df['X = 0',3]
df['X = 1',1]*0/df['X = 1',3] + df['X = 1',2]*1/df['X = 1',3]
df$`Y = 1`[1]*0/df$`Y = 1`[3] + df$`Y = 1`[2]*1/df$`Y = 1`[3]
df$Total[1]*0/df$Total[3] + df$Total[2]*1/df$Total[3]
########### Assignment 1#############
########### Problem 1
##Q1
prob_no_conflict = pnorm(5,4.5,0.37)
prob_cut_in = 1 - prob_no_conflict
## prob_cut_in = 0.08829145
## Therefore, the prob that the baseball game will cut into that program is 0.08829145
##Q2
prob_show = pnorm(4.5,4.5,0.37)
## prob_show = 0.5
## Therefore, the prob of the 0.5h show is 0.5
##Q3
prob_long_show = pnorm(4,4.5,0.37)
## prob_long_show = 0.08829145
## Therefore, the prob of the 1h show is 0.08829145
##Q4
library("lubridate")
cutoff_time = qnorm(0.99, 16.5, 0.37)
min_time = (cutoff_time - round(cutoff_time))*60
date_cut = make_datetime(hour = round(cutoff_time), min = min_time)
finaltime = as.character(date_cut, format='%H:%M:%S')
## finaltime = "17:21:00"
## Therefore, the 99% ensured cut-off time is 17:21:00
## Q5
cutoff_time_tail1 = qnorm(0.025, 16.5, 0.37)
cutoff_time_tail2 = qnorm(0.975, 16.5, 0.37)
min_time_1 = (cutoff_time_tail1 - round(cutoff_time_tail1))*60
min_time_2 = (cutoff_time_tail2 - round(cutoff_time_tail2))*60
date_cut_1 = make_datetime(hour = round(cutoff_time_tail1), min = min_time_1)
date_cut_2 = make_datetime(hour = round(cutoff_time_tail2), min = min_time_2)
finaltime_1 = as.character(date_cut_1, format='%H:%M:%S')
finaltime_2 = as.character(date_cut_2, format='%H:%M:%S')
## finaltime_1 =  "15:47:00"
## finaltime_2 =  "17:13:00"
## Therefore, the time slot of 95% insurance is 15:47:00 - 17:13:00
########## Problem2
####### a
df = data.frame(c(0.58,0.27,NaN),c(0.12,0.03,NaN), c(NaN, NaN, 1.00))
rownames(df) = c("X = 0", "X = 1", "Total")
colnames(df) = c("Y = 0", "Y = 1", "Total")
df[1:2,"Total"] = df$`Y = 0`[1:2] + df$`Y = 1`[1:2]
df["Total",] = df["X = 0",] + df["X = 1",]
#######Therefore, the table will be like
######         Y = 0 Y = 1 Total
######  X = 0  0.58  0.12   0.7
######  X = 1  0.27  0.03   0.3
######  Total  0.85  0.15   1.0
####### b
### It belongs to the discrete distribution
### And the distribution is Bernoulli distribution.
###### c
E_Y = df['Total',1]*0 + df['Total',2]*1
## Therefore, the E(Y) is 0.15 and this number means 15% earnings needs to be restated
## no matter that whether IFE serves on the board.
##### d
weight_x = c(0,1,0)
E_X = sum(df$Total*weight_x)
## Therefore, the E(X) is 0.3 and this number means in 30% cases,
## IFE serves on the firm's board.
##### e
E_Y_0 = df['X = 0',1]*0/df['X = 0',3] + df['X = 0',2]*1/df['X = 0',3]
E_Y_1 = df['X = 1',1]*0/df['X = 1',3] + df['X = 1',2]*1/df['X = 1',3]
## Therefore, the E(Y|X=0) is 0.1714286 and the E(Y|X=1) is 0.1
## E(Y|X=0) means that if there is no IFE served on the board, the expectation of restated earning is 0.1714286
## E(Y|X=1) means that if there is IFE served on the board, the expectation of restated earning is 0.1
## And it tells that having IFEs on corporate boards can reduce the possibility of restated earnings from the data of this table.
##### f
### if I know it has to restates its earning
P_X_1 = df$`Y = 1`[2]*1/df$`Y = 1`[3]
### if I don't know it had to restate its earnings
P_X = df$Total[2]*1/df$Total[3]
## Therefore, if I know it has to restate its earning, the prob is 0.2
## If I don't know whether it has to restate its earning, the prob is 0.3
##### g
## They are not independent, because if they are independent, P(X = 1) = P(X = 1|Y = 1)
## However, in question f, we have proved that those two values are not equal
## Therefore, they are not independent.
P_X
P_X_1
P(X >= 50) = pnorm(40, 45.10607, 2.469763, lower.tail = T)
pnorm(40, 45.10607, 2.469763, lower.tail = T)
pnorm(50, 45.10607, 2.469763, lower.tail = T)
pnorm(50, 45.10607, 2.469763, lower.tail = F)
P(X >= 50) = punif(50, 30, 60, lower.tail = T)
punif(50, 30, 60, lower.tail = F)
qnorm?
sd
?qnorm
qnorm(1,lower.tail = F)
qnorm(1,lower.tail = T)
pnorm(1,lower.tail = T)
pnorm(1,lower.tail = F)
pnorm(50, 45.10607, 2.469763, lower.tail = F)
qnorm(-1)
pnorm(-1)
qnorm(0.95)*0.6 + 4.2
qnorm(-2)
pnorm(2)
pnorm(-2)
pnorm(56,60,4)
pnorm(52,60,4)
pnorm(46,40,3)
qnorm(1.28)
pnorm(-1.28)
pnorm(-1.96)
pnorm(-1.28)
pnorm(2.33)
pnorm(2.33, lower.tail = T)
pnorm(2.33, lower.tail = F)
2*pnorm(-2.33)
##########################################################################################################
###                                      Core Statistics Using R                                       ###
###                                   Simple Linear Regression in R                                    ###
##########################################################################################################
############# Simple linear regression in R
######## Clear
rm(list=ls()); # deleting all objects from the memory
gc(); # garbage collection - releasing memory when an object is no longer used
######## Example: House prices
#### Load data
hprices = read.csv(url("http://hanachoi.github.io/datasets/hprices.csv"), header=TRUE, sep=",")
# hprices = read.csv("hprices.csv", header=TRUE, sep=",") # Set appropriate working directory and/or the file path!
#### Describe and visualize data
head(hprices) # first few rows to see how this dataset looks like
summary(hprices) # get some summary stats
hist(hprices$sqrft) # histogram for house sizes
hist(hprices$sqrft, breaks = 20) # more bins
hist(hprices$price) # histogram for house prices
hist(hprices$price, breaks = 20)
plot(hprices$sqrft, hprices$price) # scatter plot: size versus prices
cor(hprices)
#### Estimate regression coefficients (beta0, beta1)
## Method: Using the formulas directly
beta1_hat = cov(hprices$sqrft, hprices$price) / var(hprices$sqrft)
beta0_hat = mean(hprices$price) - beta1_hat*mean(hprices$sqrft)
c(beta0_hat, beta1_hat)
## Method: Using "lm" command
?lm # see help
lm(price~sqrft, data=hprices) # We use the lm (linear model) command to estimate a regression
# If we want more of the output, we need to summarize the contents of the estimated model
summary(lm(price~sqrft, data=hprices)) # summary of the regression output
fit = lm(price~sqrft, data=hprices) # assign regression output to a new variable/list called "fit"
summary(fit) # same as summary above
abline(lm(hprices$price~hprices$sqrft), col="red") # add a red-color regression line to the existing plot (the last plot created above)
#### Calculating Confidence Intervals
confint(fit, level=0.95) # construct confidence intervals (note: R uses t distribution for CIs)
confint.default(fit, level=0.95) # can also get R to use Normal distribution if you prefer
#### Various sums of squares
anova(fit)
anova(fit)
qnorm(0.1)
qnorm(2)
qnorm(0.99)
qnorm(-0.1)
qnorm(0.1)
qnorm(0.9)
pnorm(0.1)
pnorm(1.28)
pnorm(1.96)
######## Clear
rm(list=ls()); # deleting all objects from the memory
gc(); # garbage collection - releasing memory when an object is no longer used
library(sandwich)
library(lmtest)
setwd("/Users/fanfan/Documents/2022fallA/GBA462R/Assignment5")
library("readxl")
data2 = read_excel("Store24Data.xlsx")
fit5 = lm(Profit~MTenure+I(MTenure**2)+CTenure+I(CTenure**2)+Pop+Comp+Visibility+PedCount+Res+Hours24,data=data2)
summary(fit5)
